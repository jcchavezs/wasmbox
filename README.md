# WasmBOX

Write profesional tooling for init containers in your preferred language and run it in web assembly.

## The problem

Deploying an application could be tricky. In most of the cases you just need to bootstrap a process and enjoy it but sometimes you need to fulfill a set of preconditions to make sure your application has everything ready to run.

To overcome that issue kubernetes created init containers:

> specialized containers that run before app containers in a Pod. Init containers can contain utilities or setup scripts not present in an app image.

Things like the following are typical use cases for init containers:

- wait for dependencies
- copy assets into the main container
- transform config inputs into config outputs

Most of this work is done through scripting, usually bash or python declared inline in the deployment:

```yaml
initContainers:
  - name: build-config
    image: busybox:1.36.1
    command: [ "/usr/bin/transform.sh" ]
    args: [ "/opt/db/input.conf", "/etc/myapp/new.conf" ]
    volumeMounts:
    - mountPath: /opt/db
      name: my-db-secret
    - mountPath: /usr/bin
      name: transform-configmap
    - mountPath: /etc/myapp
      name: new-conf
```

and `transform.sh` is usually a bash file that we test manually and beg to run the same when deployed.

There are several problems on this approach:

1. The way we embed `transform.sh` is as a config map which forces us to manually copy the script content into a config file with certain identation.
1. Given 2, manually testing the script is already cumbersome and testing it at unitary level is merely impossible because we need to copy the content of the configmap, fix identation and test it manually.
1. Depends on certain binaries to be available.
1. It is bash.

## The solution

Wasmbox allows you to write the tools in your language of preference, test with your favourite test framework, compile it to webassembly and generate a configmap that later can be invoked as a init container.

For example:

```go
//go:generate wasmboxgen -o configmap.yaml example

package main

import "fmt"

func main() {
 fmt.Println("Hello, World!")
}
```

running `go generate ./...` will turn it into a config map:

```yaml
# Code generated by "wasmboxgen"; DO NOT EDIT.

apiVersion: v1
kind: ConfigMap
metadata:
  name: example
  namespace: default
binaryData:
  transform.wasm.gz: |
    H4sIAAAAAAAA/5T9DZxdR3EgivfX ...
```

and use it as init container:

```yaml
initContainers:
  - name: build-config
    image: wasmbox
    args: [ "/usr/bin/build-config.wasm", "/opt/db/input.conf", "/etc/myapp/new.conf" ]
    volumeMounts:
    - mountPath: /opt/db
      name: my-db-secret
    - mountPath: /usr/bin
      name: transform-configmap
    - mountPath: /etc/myapp
      name: new.conf
```

### How is this better?

1. Code can be writen in the language of choice.
1. Code can be tested as part of CI.
1. Generation of configmap is automated.
1. Init container image is alpine with two programs installed, no more, no less where as more complicated scripting will require you to use busybox or create custom images that have to be added to the registry, secured and maintained.
